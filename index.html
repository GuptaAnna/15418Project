<!DOCTYPE html>
<html>
<title>15418 Project</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
body {font-family: "Lato", sans-serif}
  
table {
    border-collapse: collapse;
    width: 100%;
}

td, th {
    border: 1px solid #dddddd;
    text-align: left;
    padding: 8px;
}
</style>
<body>

<!-- Navbar -->
<div class="w3-top">
  <div class="w3-bar w3-black w3-card-2">
    <a class="w3-bar-item w3-button w3-padding-large w3-hide-medium w3-hide-large w3-right" href="javascript:void(0)" onclick="myFunction()" title="Toggle Navigation Menu"><i class="fa fa-bars"></i></a>
    <a href="#" class="w3-bar-item w3-button w3-padding-large">HOME</a>
    <a href="#proposal" class="w3-bar-item w3-button w3-padding-large w3-hide-small">PROPOSAL</a>
    <a href="#checkpoint" class="w3-bar-item w3-button w3-padding-large w3-hide-small">CHECKPOINT</a>
    <a href="#report" class="w3-bar-item w3-button w3-padding-large w3-hide-small">FINAL REPORT</a>
  </div>
</div>

<!-- Page content -->
<div class="w3-content" style="max-width:2000px;margin-top:46px">
  
  <!-- The Home Section -->
  <div class="w3-container w3-content w3-center w3-padding-32" style="max-width:800px">
    <!-- Home -->
    <h1> Solving the 15-Puzzle with Parallel A* </h1>
    <h3> William Xiao (williamx), Anna Gupta (annag) </h3>
  </div>

  <!-- The Proposal Section -->
  <div class="w3-container w3-content w3-center w3-padding-32" style="max-width:800px" id="proposal">
    <h1> Proposal </h1>
    
    <p class="w3-justify">
    <font size="5"> Title </font>
    <br>
    Solving the 15-Puzzle with Parallel A*
    </p>
    
    <p class="w3-justify">
    <font size="5"> Summary </font>
    <br>
    We will implement a parallel version of the A* algorithm to solve the 15-Puzzle with minimal moves on the Gates 
    or latedays machines.
    </p>
    
    <p class="w3-justify">
    <font size="5"> Background </font>
    <br>
    The 15-Puzzle consists of a 4x4 frame of square tiles (numbered from 1 to 15), with one tile missing. 
    The object of the game is to place the tiles in numerical order by sliding tiles, using the empty space.
    The puzzle can come in different sizes; in general, a NxN frame will use tiles numbered from 1 to N<sup>2</sup> - 1. 
      
    <br>
    The game can be represented as a graph, with nodes being the state of the board and edges representing an action 
    (sliding a particular tile). We would like to implement a graph-searching algorithm to find the shortest sequence of moves
    to solve the puzzle. 
      
    <br>
    In graph-search algorithms, a heuristic ranks edges from a node, based on an algorithm. This decides which actions are preferable, 
    given the state of the game. The 15-Puzzle is perfect for an algorithm involving heuristics. One possible heuristic for the puzzle 
    uses the taxicab distances for each tile (difference in distance between actual and desired positions). This opens the door for us 
    to use A* (or other heuristic algorithms) to solve the puzzle. 
    
    <br>
    <center>
    <img src="Fifteen_puzzle.png" alt="Fifteen Puzzle">
    </center>
    </p>
    
    <p class="w3-justify">
    <font size="5"> The Challenge </font>
    <br>
    Unlike other graph-search algorithms, A* is difficult to implement in parallel due to the heuristic. The sequential version of
    the algorithm utilizes a priority queue, ranking the nodes by cost or preference. In an iteration, the least-cost node is popped 
    from the priority queue, information is updated, and the neighbors of the node are added to the queue. These neighbors could 
    have a higher preference than nodes previously existing in the queue, making it difficult to utilize multiple threads. It might 
    not be viable to have multiple threads working on different nodes in the queue - since the second-preferred node in the queue 
    may not be the first-preferred node after the iteration. 
    </p>
    
    <p class="w3-justify">
    <font size="5"> Resources </font>
    <br>
    We will start writing code from scratch. We will research A* and other heuristic algorithms to determine 
    one that is optimal for solving the 15-Puzzle. We will also determine a benchmark for speed-up that can 
    be acquired by parallelizing A* by reading research papers. We will utilize the Gates or latedays clusters 
    for our project. 
    </p>
    
    <p class="w3-justify">
    <font size="5"> Goals &amp; Deliverables </font>
    </p>
    Goals: 
    <ul class="w3-justify">
    <li> Implement a sequential version of A* in the context of the 15-Puzzle </li>
    <li> Research the A* algorithm and determine a desired speed-up goal between sequential and parallel versions </li>
    <li> Implement a parallel version using CUDA, achieving the desired speed-up </li>
    <li> Compare speed-up across varying number of threads and determine an optimal number of threads to use</li>
    <li> Test our implementation on larger versions of the 15-Puzzle, varying the width of the board</li>
    </ul> 
      
    If time permits:
    <ul class="w3-justify">
    <li> Experiment with variants of the A* algorithm and compare which results in the largest speedup</li>
    <li> Achieve parallelism through different method - for example, using OpenMP </li>
    </ul> 
    
    <p class="w3-justify">
    We will construct a rubric for our work by researching prior attempts to parallelize A* and the speed-ups they received. 
    Ideally, we would like to achieve as close to the best speed-up achieved as possible.
    </p>
    
    <p class="w3-justify">
    <br>
    <font size="5"> Platform Choice </font>
    <br>
    CUDA will give us access to a large number of threads - which will be useful in solving large instances of the puzzle. 
    In addition, we can utilize thread blocks and shared memory as a form of communication between the threads. 
    </p>
    
    <p class="w3-justify">
    <font size="5"> Schedule </font>
    </p>
    
    <table>
      <tr>
        <th>Week of:</th>
        <th>Task</th>
      </tr>
      <tr>
        <td>April 17</td>
        <td>Determine benchmark for speed-up; Implement a sequential version of A*</td>
      </tr>
      <tr>
        <td>April 24</td>
        <td>Research and implement a parallel version of A*</td>
      </tr>
      <tr>
        <td>May 1</td>
        <td>Test and make implementation scalable on different sized grids </td>
      </tr>
      <tr>
        <td>May 8</td>
        <td>Optimize implementation and finish final report + presentation</td>
      </tr>
    </table>
  </div>
    
  <!-- The Checkpoint Section -->
  <div class="w3-container w3-content w3-center w3-padding-32" style="max-width:800px" id="checkpoint">
    <h1> Checkpoint </h1>
    
    <p class="w3-justify"> 
    <font size="5"> Work Completed </font>
    <br>
    The goal of our project is to implement a parallel version of A* to solve the 15-Puzzle. 
    We've successfully implemented a sequential version of the algorithm. In particular: 
    </p>
    <ul class="w3-justify">
    <li> We created an abstract State class, representing the state of the game at a point in time. The class has both implemented
         and virtual methods. The implemented methods are general and related to A*, while the virtual methods are defined 
         in the extending class. This design generalizes the state class, allowing it to be used for different games. </li>
    <li> We created a Board class to extend the State class. We represent the game board with a 2-D array of integers, 
         storing the numbers of the tiles. We allow a board to be created in two ways: 
         <ul>
           <li> Randomly generating a permutation of the numbers in the range 1 to n. We check if the board layout has a valid
                solution (in the context of the 15-Puzzle); if not, we fix it by swapping two numbers. </li>
           <li> Starting from the goal board and randomly making valid moves </li>
         </ul>
    </li> 
    <li> We implemented our own priority queue class, as the c++ library does not support an efficient remove function. We utilize 
          this priority queue implementation in the A* algorithm.  </li>
    <li> We developed a sequential version of the A* algorithm using the State class. Going forward, our parallel version 
      will also use the State class. </li>
    </ul> 
    
    <p class="w3-justify"> 
    <font size="5"> Updated Schedule </font>
    <br>
    </p>
    
    <table>
      <tr>
        <th>Time Period:</th>
        <th>Task: William</th>
        <th>Task: Anna</th>
      </tr>
      <tr>
        <td>April 24-27</td>
        <td>Brainstorm different methods of parallelizing A*</td>
        <td>Research and understand shared priority queues</td>
      </tr>
      <tr>
        <td>May 2-5</td>
        <td>Implement parallel version of A*</td>
        <td>Implement parallel version of A*</td>
      </tr>
      <tr>
        <td>May 6-9</td>
        <td>Test implementation on larger grids + make optimizations as necessary </td>
        <td>Compare speed-up across threads + determine optimal number of threads</td>
      </tr>
      <tr>
        <td>May 10-12</td>
        <td>Finish final report + presentation</td>
        <td>Finish final report + presentation</td>
      </tr>
    </table>
    
    <p class="w3-justify"> 
    <font size="5"> Updated Goals &amp; Deliverables </font>
    <br>
    So far, we are on schedule, as detailed in our proposal. We have begun researching possible ways to parallelize A* and
    designing our implementation. In previous attempts of parallel A*, researchers have sacrificed optimality of the solution
    for speed. Therefore, the parallel versions, although fast, may not return the best solution.
    <br>
    Going forward, one concern we have is whether we will have to sacrifice optimality as well. Initially, we hoped to achieve 
    great speed-up while also returning the optimal solution. If time permits, we will implement multiple versions of parallel
    A*, varying in optimality of the solution. From this, we can compare the correlation between speed-up and suboptimality. 
    <br>
    </p>
    Updated Goals:
    <ul class="w3-justify">
    <li> Optimize State and/or Board classes to improve both sequential and parallel efficiency </li>
    <li> Determine a desired speed-up goal for the parallel algorithm compared to the baseline </li>
    <li> Implement a parallel version using CUDA, based on results of research papers </li>
    <li> Determine an optimal number of threads to use for the parallel version </li>
    <li> Test our implementation on larger board sizes of the puzzle </li>
    </ul> 
    
    <p class="w3-justify"> 
    <font size="5"> Other Information </font>
    <br>
    For the parallelism competition, we will provide both a demo and graph. The demo will show the steps in order to solve the 
    puzzle optimally. Therefore, the user could follow the printed steps to solve a randomly generated puzzle. 
    We will also present a graph to demonstrate
    speed-up between the sequential version that we've already implemented and the parallel version that we will implement in the future. 
    </p>
  </div>

  <!-- The Final Report Section -->
  <div class="w3-container w3-content w3-center w3-padding-32" style="max-width:800px" id="report">
    <h1> Final Report </h1>
    
    <p class="w3-justify">
    <font size="5"> Summary </font>
    <br>
    We parallelized the A* algorithm, for use in solving the 15-Puzzle optimally. To achieve parallelism, we utilized pthreads and 
    tested on the GHC machines. 
    </p>
    
    <p class="w3-justify">
    <font size="5"> Background </font>
    <br>
      - describe A* 
      - describe the 15-puzzle
      - priority queue
      - hash table
      A*: A* is a heuristic-based pathfinding algorithm. Given a weighted-graph and two nodes, the algorithm finds the shortest path between them. 
      A algorithm uses two functions: we'll name them <b>g(n)</b> and <b>h(n)</b>. <b>g(n)</b> is the cost from the start to <i>n</i>, or 
      the sum of the edges connecting start and <i>n</i>. <b>h(n)</b> is a heuristic, a function that estimates the cheapest cost from 
      <i>n</i> to the goal. This function must be admissible, meaning it never overestimates the actual cost. Together, <b>f(n)</b> = 
      g(n) + h(n), which represents the priority of the node. A lower f value means a lower cost is incurred to travel
      through that node, ensuring a higher priority. The algorithm will explore nodes in order of priority. 
      
      <br>
      15-Puzzle: This puzzle fits perfectly in the context of A*. Each board arrangement represents a node in the graph, with edges 
      representing possible moves in the game. Therefore, two board arrangements will be connected by an edge if 
    </p>
    
    <p class="w3-justify">
    <font size="5"> Approach </font>
    <br>
    
    </p>
    
    <p class="w3-justify">
    <font size="5"> Results </font>
    <br>
    
    </p>
    
    <p class="w3-justify">
    <font size="5"> References </font>
    <br>
    
    </p>
    
    <p class="w3-justify">
    <font size="5"> Distribution of Work </font>
    <br>
    
    </p>
  </div>
  
  
<!-- End Page Content -->
</div>

</body>
</html>
